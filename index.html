<!DOCTYPE html>
<html>
<head>
  <title>Symbols and Hashes</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link rel="stylesheet" type="text/css" media="screen" href="slides.css">
</head>
<body>
  <textarea id="source">
class: center, middle

# Symbols & Hashes

<big>Alicia Lauerman</big>
### [@tealtail](http://twitter.com/tealtail)</small>

---

# Agenda

In the following slides, we will cover the following topics:

* I DON'T KNOW!

---

### Ruby Collection
## Hashes

Similar to an array, but in a hash we can refer to a member's index by a keyword instead of a number. Each member is a pair:

* Key: index address of the hash member

* Value: variable contained by the member, and located by key name. Can be objects of any type.

A hash may also be referred to as a `dictionary`, `associative array`, or `map`.

???
Hashes are similar to arrays in that they are both indexed collections of object references. However, while you index arrays with integers, you can index a hash with objects of any types: strings, regular expressions, and so on. When you store a value in a hash, you actually supply two objects * the index (normally called the key) and the value. You can later retrieve the value by indexing the hash with the same key. The values in a hash can be objects of any type.

---
## Creating a Hash

.left-column[
### - Hash.new
]

.right-column[
Calling Hash.new will initialize a new, empty hash object
```
>> heroes = Hash.new
# => {}
```
]

???
So here I'm demonstrating one way to create a hash. I call Hash.new
to instantiate a new instance of the Hash class, and afterward, the response I get back is these two little curly braces here, which is ruby's way of letting me know that it's a hash.

In fact, I could also use this, these two curly braces to accomplish the exact same thing
---

## Creating a Hash

.left-column[
### - Hash.new
### - hash = {}
]

.right-column[
You can also use `{}` to accomplish the same thing. Nifty!
```
>> heroes = {}
# => {}
```
]

---

## Creating a Hash

.left-column[
### - Hash.new
### - hash = {}
### - Add the things!
]

.right-column[
Use the `[]` operator (brackets) to add keys and assign their values, as well as modify them

```
>> heroes["Batman"] = "Bruce Wayne"
>> heroes["Superman"] = "Clark Kennt" # oops!
>> heroes["Superman"] = "Clark Kent" # value is updated
>> heroes.size
# => 2
>> puts heroes
# => {"Batman" =>"Bruce Wayne", "Superman" =>"Clark Kent"}
```
]

???
Once we have a hash, if we want to add items to it we can do that by using the brackets to assign values to a new key, here we're adding the new key batman, with his secret identity Bruce Wayne, as well as the superman key that will be associated with his secret identity, Clark Kent. I misspelled it the first time but it's easy enough to change that.

---

## Creating a Hash

.left-column[
### - Hash.new
### - hash = {}
### - Add the things!
### - Literal Syntax
]

.right-column[
Hash Literal

* list of key => value pairs
* commas separate each pair
* each key has a `=>` (a hash rocket) pointing to its value.
* pairs are wrapped between two curly braces (aka curly brackets)


```
>> heroes = { :Batman => "Bruce Wayne", :Superman => "Clark Kent" }
>> puts heroes
# => {:Batman=>"Bruce Wayne", :Superman=>"Clark Kent"}
```
]

???
We could also choose to create hashes using something called a hash literal. We wrap a comma seperated list of key/value pairs inside of curly braces. Each key points to its value with a hash rocket. This lets us both instantiate the hash and define it's members in one go.

But wait, something else is different here - Take a look at the keys in this hash. I'm using symbols now instead of strings. I can actually take advantage of a newer variation of hash literal that was introduced in ruby 1.9 because of this.

--

.right-column[
Ruby 1.9 Hash Literal
```
>> heroes = { Batman: "Bruce Wayne", Superman: "Clark Kent"}
>> puts heroes
# => {:Batman=>"Bruce Wayne", :Superman=>"Clark Kent"}
```
]

???
A symbol is a special kind of object in ruby, whose value is itself. You'll know it's a symbol when it has a colon stuck to the front of it.

So, when the keys in your hash are symbols, and you're using ruby 1.9 or later, you can opt to create your hashes this way, doing away wih the hash rockets we saw before and just pinning the colon to the end of a symbol instead of at the beginning. It's not a requirement, but it does seem more concise, I think. Maybe a bit cleaner. It's just a matter of taste, but you'll still need to use the hash rockets when your hash keys are some other arbitrary type.

---

class: center, middle

# Prefer using symbols as hash keys, instead of strings

---
## Symbols

### look like variable names, prefixed with a colon.

--
.octocat[![octocat](images/bear-cavalry.jpg)]
## .right[  for example, `:octocat` ]

--
.left[
A symbol is:

* an object with a name
* closely related to String (but can't do many "stringy" type things)
* easily converted to string with `to_s`
]

```
>> :octocat.to_s
# => "octocat"
>> "octocat".to_sym
# => :octocat
>> :octocat.methods.size
# => 86
>> "octocat".methods.size
# => 171
```

???
So, a symbol is an object that can be uniquely identified by it's name. It's value is itself. It is its own primitive type, and many string operations cannot be performed on it, but if you need to, you can get the string value of any symbol by calling to_s.

---
## Strings

.left-column[
### are MUTABLE
]

.right-column[
The value of a string can be changed at anytime.

```ruby
>> greeting = "HELLO"
>> greeting[1] = "A"
>> puts greeting
# => "HALLO"

>> greeting.downcase!
>> puts greeting
# => "hallo"
```
]

???
Because Strings are mutable, meaning they can be changed anytime, the Ruby interpreter never knows what that String may hold in terms of data. As such, every String needs to have its own place in memory.

---
## Strings

.left-column[
### are MUTABLE
### are garbage-collected
]

.right-column[
Even if they happen to contain the same value as any string before it, each and every string will be stored as a new object in memory.

```ruby
>> puts "hello".object_id # => 70319785054740
>> puts "hello".object_id # => 70319784980180
>> puts "hello".object_id # => 70319785054740
>> puts "hello".object_id # => 70319784575320
>> puts "hello".object_id # => 70319784540680
```

We are creating a new object (five times), storing and ultimately destroying it when reusing the same object would be much more efficient.
]

???
For example, if you have a string "hello" multiple times mentioned in your code, Ruby needs to store all of these as separate String objects, because they might change later on. We can see this here where I'm creating some Strings and printing their object ids.

Behind the scenes, there is some heavy waste going down.

1. First, a new String object is instantiated with the value of hello.

2. The Ruby interpreter needs to look at the heap (your computers memory), find a place to put the new string and keep track of it via its object id.

3. The String is passed to the puts method, and output to the screen.

4. The Ruby interpreter sees that the String will not be used again as it is not assigned to a variable, and marks it for destruction.

5. Back to step one four more times.

We are creating a new object, storing and ultimately destroying it when reusing the same object would be much more efficient. So Lets do the same thing but with Symbols instead.

---

## Symbols

* are unique
* are immutable
* are NOT garbage collected

Same symbol, same object_id. A Ruby symbol cannot be changed at runtime. Ruby symbols are often used as hash keys, because we do not need full capabilities of a string objects for a key.

```
>> puts :hello.object_id # => 495948
>> puts :hello.object_id # => 495948
>> puts :hello.object_id # => 495948
>> puts :hello.object_id # => 495948

>> :hello == :hello # => true
>> :hello.equal? :hello # => true
>> :hello.equal? "hello".to_sym # => true
```

???
This time, we see that every Symbol shares the same object id, and as such the same space on the heap. Ruby will not mark Symbols for destruction, allowing you to reuse them again and again.

---

class: center, middle

## "Strings are about a sequence of characters. Symbols are about naming and identifying things."
 [Symbols Are Not Immutable Strings](http://onestepback.org/index.cgi/2005/12/27) - Jim Weirich

???
Whenever you would otherwise use a quoted string as a hash key, use a symbol instead.

Using symbols not only saves time when doing comparisons, but also saves memory, because they are only stored once.

So let's make a new hash, this time using symbols where we might have used a string earlier.

---

## Accessing objects in a hash

Every hash object has the methods `keys` and `values` available to it. The `keys` method returns an array of all the keys in the Hash. Similarly, `values` returns an array of just the values.

```
>> heroes.keys
# => ["Batman", "Superman"]
>> heroes.values
# => ["Bruce Wayne", "Clark Kent"]
```

--

Since each key in a hash must be unique, retrieving a stored value is as simple as referencing its key inside of `[]`.
```
>> heroes["Batman"]
# => "Bruce Wayne"
>> heroes["Superman"]
# => "Clark Kent"
```
---
## Accessing objects in a hash

### But what if we try to access a key that doesn't exist?



```
>> heroes.keys
# => ["Batman", "Superman"]
>> heroes["Supermann"]
# => nil
```

???
We get back `nil` because that's currently the default for any value in our hash :/
---

## Accessing objects in a hash
### A better way, using the fetch method

Use `fetch(key)` to retrieve stored values

```
>> heroes.fetch("Batman")
# => "Bruce Wayne"
>> heroes.fetch("Supermann")
# => KeyError: key not found: "Supermann"
```

The `fetch` method will read the value of a given key, But if the key isn't found, an exception is raised.

---

## Iterating over hashes

You can use the `each` method to iterate over all the elements in a Hash. However unlike `Array#each`, when you iterate over a Hash using `each`, it passes two values to the block: the key and the value of each element.

```
>> restaurant_menu = { Ramen: 3, Burrito: 4, Coffee: 2 }
>> restaurant_menu.each do | item, price |
>*   puts "#{item} - $#{price}"
>> end
```
produces:

```
Ramen - $3
Burrito - $4
Coffee - $2
```


  </textarea>
  <script src="remark/remark.min.js" type="text/javascript">
  </script>
  <script type="text/javascript">
    var slideshow = remark.create(
    {
      highlightLanguage: "ruby",
      highlightStyle: "tomorrow-night-eighties",
      ratio: "16:9"
    });
  </script>
</body>
</html>
